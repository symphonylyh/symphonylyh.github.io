> Collect C++ syntax and basic usage.

Important edge cases:
* Array (1D/2D) boundary
* NULL input (NULL ptr, "" empty string)
* Integer overflow

### Vector
Vector is dynamic length array, which automatically reallocate elements as needed (2x capacity each time).

```c
#include <vector>
using namespace std;

// Initialize
return vector<int>{1,2}; // direct construct
vector<int> v = {1,2}; // known initializer
v.assign(size, val); // assign $size elements, all $val

// Modify
v.push_back(10); v.emplace_back(10);
v.pop_back();

// $pos below should be iterator, v.begin() etc.
v.insert(pos, val); // single insert: insert $val at $pos, [0~pos-1] stays, the old [pos] becomes [pos+1]
v.insert(pos, size, val) // replica insert: insert $size elements of $val at $pos
v1.insert(pos, v2.it1, v2.it2) // concat: insert v2[it1-it2] to v1 at $pos

// Properties
v.size(); v.capacity();
v.reserve(size);
v.empty(); // true/false
v.clear();
v.erase(pos); v.erase(it1, it2); // [it1, it2)
v1.swap(v2);

// Access and Traverse (iterator)
// Iterator .begin(), .end(), .rbegin(), .rend()
// Use * to dereference iterator!
v[10]; v.at(10); v.front(); v.back();
for (auto i : v) { cout << i << endl;} // by value
for (const int& i : v) { cout << i << endl;} // by reference
for (auto i = v.begin(); i != v.end(); i++) { cout << *i << endl;} // by iterator
for (auto i = v.rbegin(); i != v.rend(); i++) { cout << *i << endl;} // reverse iterator

// Sort
sort(vec.begin(), vec.end()); // in-place
```

### Pair (utility)
Tuple of two different types, accessed by .first and .second.

```c
#include <utility>
using namespace std;

pair <string, int> p = make_pair("hello", 1);
pair <string, int> q("wow", 2);
q = make_pair("hi", 3);

// Operator
p == q // both first & second should be equal
p != q // complement ==
p >= or <= q // compare first field
p.swap(q)
```

### Hash Table (unordered_map)
Key-Value pair data structure, keys are unordered. Implemented by hash table. Amortized O(1).
```c
#include <unordered_map>
using namespace std;

// Initialize
unordered_map<string, int> umap;

// Insert
umap["hi"] = 10;
umap.insert(make_pair("wow", 3));

// Existence
if (umap.find(key) != umap.end()) { // exists }

// Traverse (.first for key, .second for val)
for (auto item : umap) {
    cout << item.first << " " << item.second << endl;
}
for (unordered_map<string, int>::iterator it = umap.begin(); it != umap.end(); it++) {
    cout << it->first << " " << it->second << endl;
}
```

### Map (map)
Key-Value pair data structure, keys are ordered. Implemented by balanced tree. Order is maintained by tree traversal. O(logn)

```c

```

### Hash Set (unordered_set)
Key-only data structure, often used to check for presence/absence. Amortized O(1).
```c
#include <unordered_set>
using namespace std;
```
### Const-ness
Syntax: Read right-->left, Divide by `*`, `*` reads as "points to"
Examples:
```c
const char *p; // p points to a const char (char immutable)
char const *p; // p points to a const char (char immutable). Because const is still before *!
char* const p; // p constantly points to char (p immutable)
const char * const p; // p constantly points to a const char (both immutable)
```

* const member variable in a class can only be initialized using a **initializer list**, `A(int x) : var(x) {}; // if const int var;`
* const member function in a class `void fun() const` can't modify any member variable & can't call non-const functions.
* remove const-ness, `char* const p; int* q = const_cast<int*>(p);` now `q` is a non-const ptr.

### Type casting
<details><summary>Hidden</summary>

Different types of cast indicates different restrictive levels during **compile-time** and **run-time**. Up-cast (cast to base class i.e. polymorphism) is always legal. Down-cast has restrictions.

C-style cast:
```c
ClassA* ptr_a = new ClassA();
ClassB* ptr_b = (ClassB*)ptr_a;
```
It will try `const_cast`, `static_cast`, `reinterpret_cast` but NOT `dynamic_cast`. So it's **unsafe** since it can't catch base-->derived error. A good style is, use this regular cast to manipulate numeric values, but use appropriate cast (recommended `static_cast`) for class/type casting.

Four C++ types:
* `static_cast`, mostly used. Like C-style cast
* `dynamic_cast`, from derived-->base, just like `static_cast`; from base-->derived, requires base class has a virtual table (return NULL if cast fails, so safer than   `static_cast` for base-->derived case).
* `const_cast`, add/remove const-ness
* `reinterpret_cast`, force cast without compiler check

</details>

### Virtual Table (inheritance under the hood)
When a class defines virtual methods, a virtual table (simply an array of pointers) will be generated in memory and **all its instances will store a pointer(\*\*) to the table**. That's why an instance of an empty class (no member variables) will have `sizeof() == 4 or 8`. That's the virtual table pointer.

Suppose base class A has virtual functions X,Y,Z.
* Class B inherits A and but **doesn't overwrite** virtual X,Y,Z, instead it defines it's own virtual functions U,V,W. Then A's V-table is:
`| X | Y | Z`
B's V-table is:
`| X | Y | Z | U | V | W`
* Class B inherits A and **overwrites** virtual X,Y (denoted as X', Y') but not Z. Then B's V-table is:
`| X' | Y' | Z |`
