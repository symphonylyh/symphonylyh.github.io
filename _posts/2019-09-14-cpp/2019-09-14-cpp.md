> Collect C++ syntax and basic usage.

Important edge cases:
* Array (1D/2D) boundary
* NULL input (NULL ptr, "" empty string)
* Integer overflow


Table of Contents:
* [Sequence `<vector> & <deque> & <list>`](#sequence)
* [LIFO/FIFO `<stack> & <queue>`](#lifofifo)
* [Pair `<utility>`](#pair)
* Hash structures:
  * [Hash Set `<set> & <unordered_set>`](#hash-set)
  * [Hash Table `<map> & <unordered_map>`](#hash-table)
  * [Multi Hash `<multimap> & <unordered_multimap> & <multiset> & <unordered_multiset>`](#multi-hash)

### Sequence
#### `<vector>`
Continuous memory. Dynamic.
* O(1) query.
* O(1) insert/delete at end.
* O(n) insert/delete at other locations.

```c
#include <vector>
using namespace std;

// Initialize
return vector<int>{1,2}; // direct construct
vector<int> v = {1,2}; // known initializer
v.assign(size, val); // assign $size elements, all $val

// Modify
v.push_back(10); v.emplace_back(10);
v.pop_back();

// $pos below should be iterator, v.begin() etc.
v.insert(pos, val); // single insert: insert $val at $pos, [0~pos-1] stays, the old [pos] becomes [pos+1]
v.insert(pos, size, val) // replica insert: insert $size elements of $val at $pos
v1.insert(pos, v2.it1, v2.it2) // concat: insert v2[it1-it2] to v1 at $pos

// Properties
v.size(); v.capacity();
v.reserve(size);
v.empty(); // true/false
v.clear();
v.erase(pos); v.erase(it1, it2); // [it1, it2)
v1.swap(v2);

// Access and Traverse (iterator)
// Iterator .begin(), .end(), .rbegin(), .rend()
// Use * to dereference iterator!
v[10]; v.at(10); v.front(); v.back();
for (auto i : v) { cout << i << endl;} // by value
for (const int& i : v) { cout << i << endl;} // by reference
for (auto i = v.begin(); i != v.end(); i++) { cout << * i << endl;} // by iterator
for (auto i = v.rbegin(); i != v.rend(); i++) { cout << * i << endl;} // reverse iterator

// Sort
sort(vec.begin(), vec.end()); // in-place
```
Difference between `emplace_back()` and `push_back()`: `emplace_back` does an **in-place** constructor/allocation for the obect, but `push_back` will call constructor followed by a **copy** ctor.

#### `<list>` doubly-linked list
Discontinuous memory. Dynamic. Memory costy.
* O(n) query
* O(1) insert/delete at all locations

#### `<deque>` double-ended queue
Discontinuous memory. Dynamic. Memory costy. Like a combo of vector and list, which allows efficient O(1) query and O(1) edge insert/delete.
* O(1) query (but two pointer redirection using bookkeeping technique, where vector is only one direct pointer operation)
* O(1) insert/delete at begin & end
* O(n) insert/delete at other locations



### LIFO/FIFO

#### `<stack>`
```c
#include <stack>
using namespace std;

stack<int> s; // define type

s.push(10);
s.emplace(20); // better than push
s.pop(); // remove

// top() returns a reference
int t = s.top(); // or int& t = s.top();

s.empty();
s.size();

s1.swap(s2);
```

#### `<queue>`
```c
#include <queue>
using namespace std;

queue<int> q; // define type

q.push(10);
q.emplace(20); // better than push
q.pop(); // remove
int f = q.front(); // or int& f = q.top();
int b = q.back();

q.empty();
q.size();

q1.swap(q2);
```

### Pair
Tuple of two different types, accessed by .first and .second.

```c
#include <utility>
using namespace std;

pair <string, int> p = make_pair("hello", 1);
pair <string, int> q("wow", 2);
q = make_pair("hi", 3);

// Operator
p == q // both first & second should be equal
p != q // complement ==
p >= or <= q // compare first field
p.swap(q)
```

### Hash Set
Key-only data structure, often used to check for presence/absence. Amortized O(1).
```c
#include <unordered_set>
using namespace std;
```

### Hash Table
#### `<unordered_map>`
Key-Value pair data structure, keys are unordered. Implemented by hash table. Amortized O(1).
```c
#include <unordered_map>
using namespace std;

// Initialize
unordered_map<string, int> umap;

// Insert
umap["hi"] = 10;
umap.insert(make_pair("wow", 3));

// Existence
if (umap.find(key) != umap.end()) { // exists }

// Traverse (.first for key, .second for val)
for (auto item : umap) {
    cout << item.first << " " << item.second << endl;
}
for (unordered_map<string, int>::iterator it = umap.begin(); it != umap.end(); it++) {
    cout << it->first << " " << it->second << endl;
}
```

#### `<map>`
Key-Value pair data structure, keys are ordered. Implemented by balanced tree. Order is maintained by tree traversal. O(logn)

```c

```

### Multi Hash

### Const-ness
Syntax: Read right-->left, Divide by `*`, `*` reads as "points to"
Examples:
```c
const char *p; // p points to a const char (char immutable)
char const *p; // p points to a const char (char immutable). Because const is still before *!
char* const p; // p constantly points to char (p immutable)
const char * const p; // p constantly points to a const char (both immutable)
```

* const member variable in a class can only be initialized using a **initializer list**, `A(int x) : var(x) {}; // if const int var;`
* const member function in a class `void fun() const` can't modify any member variable & can't call non-const functions.
* remove const-ness, `char* const p; int* q = const_cast<int*>(p);` now `q` is a non-const ptr.

### Type casting
<details><summary>Hidden</summary>

Different types of cast indicates different restrictive levels during **compile-time** and **run-time**. Up-cast (cast to base class i.e. polymorphism) is always legal. Down-cast has restrictions.

C-style cast:
```c
ClassA* ptr_a = new ClassA();
ClassB* ptr_b = (ClassB*)ptr_a;
```
It will try `const_cast`, `static_cast`, `reinterpret_cast` but NOT `dynamic_cast`. So it's **unsafe** since it can't catch base-->derived error. A good style is, use this regular cast to manipulate numeric values, but use appropriate cast (recommended `static_cast`) for class/type casting.

Four C++ types:
* `static_cast`, mostly used. Like C-style cast
* `dynamic_cast`, from derived-->base, just like `static_cast`; from base-->derived, requires base class has a virtual table (return NULL if cast fails, so safer than   `static_cast` for base-->derived case).
* `const_cast`, add/remove const-ness
* `reinterpret_cast`, force cast without compiler check

</details>

### Virtual Table (inheritance under the hood)
When a class defines virtual methods, a virtual table (simply an array of pointers) will be generated in memory and **all its instances will store a pointer(\*\*) to the table**. That's why an instance of an empty class (no member variables) will have `sizeof() == 4 or 8`. That's the virtual table pointer.

Suppose base class A has virtual functions X,Y,Z.
* Class B inherits A and but **doesn't overwrite** virtual X,Y,Z, instead it defines it's own virtual functions U,V,W. Then A's V-table is:
`| X | Y | Z`
B's V-table is:
`| X | Y | Z | U | V | W`
* Class B inherits A and **overwrites** virtual X,Y (denoted as X', Y') but not Z. Then B's V-table is:
`| X' | Y' | Z |`
